# DBKit vs GORM 性能对比报告

生成时间: 2026-01-02

## 测试环境

| 项目 | 值 |
|------|----|
| Go Version | go1.25.5 |
| OS/Arch | windows/amd64 |
| CPU Cores | 16 |
| Database | MySQL v8 |

## 测试参数

| 参数 | 值 |
|------|----|
| 单条插入次数 | 1000 |
| 查询测试次数 | 1000 |
| 更新测试次数 | 500 |
| 批量操作大小 | 100 |

## 测试方法

为了确保测试的公平性和准确性，本测试采用以下方法：

1. **独立表测试**: DBKit 和 GORM 使用同一个数据库,不同的表（`benchmark_users_dbkit` 和 `benchmark_users_gorm`），消除 MySQL 缓存效应的影响
2. **相同测试条件**: 两者使用相同的数据量、批量大小和测试次数
3. **事务一致性**: 批量插入测试中，两者都使用事务以确保公平对比
4. **预热处理**: 每个测试前都进行预热，避免冷启动影响

## 测试结果

| 测试项 | DBKit | GORM | DBKit ops/s | GORM ops/s | 对比 |
|--------|-------|------|-------------|------------|------|
| 单条插入 | 2.2752305s | 2.805884s | 440 | 356 | DBKit 快 18.9% |
| 批量插入 | 37.1571ms | 35.3559ms | 26913 | 28284 | GORM 快 4.8% |
| 单条查询 | 614.3433ms | 631.2872ms | 1628 | 1584 | DBKit 快 2.7% |
| 批量查询(100条) | 71.4026ms | 100.1283ms | 1401 | 999 | DBKit 快 28.7% |
| 条件查询 | 707.6843ms | 709.5983ms | 1413 | 1409 | DBKit 快 0.3% |
| 更新操作 | 1.1616952s | 1.4020555s | 430 | 357 | DBKit 快 17.1% |
| 删除操作 | 1.1577656s | 1.409573s | 432 | 355 | DBKit 快 17.9% |
| **总计** | **6.0252786s** | **7.0938822s** | - | - | - |

## 结论

**DBKit 总体快 15.1%**

### 分析

#### DBKit 全面领先
本次测试中，**DBKit 在 6/7 个测试项目上超越了 GORM**，展现出明显的性能优势：

- **单条插入**: DBKit 快 18.9%
- **批量插入**: GORM 快 4.8%
- **单条查询**: DBKit 快 2.7%
- **批量查询(100条)**: DBKit 快 28.7%
- **条件查询**: DBKit 快 0.3%
- **更新操作**: DBKit 快 17.1%
- **删除操作**: DBKit 快 17.9%

#### 性能优势原因

**为什么 DBKit 在大多数场景下领先？**

1. **无反射开销**: Record 模式使用 `map[string]interface{}`，避免了结构体反射的性能损耗
2. **轻量级设计**: 默认关闭时间戳和乐观锁检查，减少不必要的开销
3. **优化的 SQL 构建**: 移除了不必要的排序操作，直接构建 SQL
4. **独立表测试**: 使用独立表消除了 MySQL 缓存效应，展现真实性能

**批量查询(100条)为什么优势最大（28.7%）？**

批量查询是 DBKit 最大的优势场景，因为：
1. Record 模式直接返回 `map[string]interface{}`，无需字段映射
2. GORM 需要通过反射将数据库结果映射到结构体字段
3. 数据量越大，反射开销越明显

**GORM 的优势场景**

GORM 在以下测试项中表现更好：
- **批量插入**: GORM 快 4.8% 

GORM 在以下场景仍有其价值：
- **复杂 ORM 功能**: 关联查询、预加载、钩子回调
- **数据库迁移**: 自动迁移和版本管理
- **生态系统**: 丰富的插件和社区支持

**总体评价**: DBKit 在大多数 CRUD 操作上都表现出色，总体性能快 15.1%，特别适合追求高性能的场景。

### 性能优化说明

DBKit 默认关闭了时间戳自动更新和乐观锁检查功能，以获得最佳性能。如需启用这些功能：

```go
// 启用时间戳自动更新
dbkit.EnableTimestampCheck()

// 启用乐观锁检查
dbkit.EnableOptimisticLockCheck()

// 同时启用两个功能
dbkit.EnableFeatureChecks()
```

启用这些功能后，Update 操作会有额外的检查开销，但仍然保持良好的性能。

### 技术差异

| 特性 | DBKit Record | GORM |
|------|--------------|------|
| 数据结构 | map[string]interface{} | 结构体反射 |
| 字段映射 | 无需映射 | 需要反射解析 tag |
| 内置功能 | 时间戳、乐观锁、软删除（可选） | 钩子、关联、迁移 |
| 灵活性 | 动态字段 | 固定结构体 |
| 性能特点 | 轻量级，低开销 | 功能丰富，开销较高 |

### 适用场景

- **选择 DBKit**: 追求高性能、动态字段、简单 CRUD、微服务、API 后端
- **选择 GORM**: 需要完整 ORM 功能、关联查询、数据库迁移、钩子回调、复杂业务逻辑
